# nogo
2022秋 计算概论A大作业


本项目音乐，美术均来源于手机游戏《明日方舟》，属于同人性质的作品。


nogo即不围棋，其游戏规则与围棋相反，对弈的目标不是吃掉对方的棋子，不是像围棋那样围空占领地盘，恰恰相反，如果一方落子后吃掉了对方的棋子，则落子一方判负。

一.概述

本程序有主菜单（可以选择调整难度【简单、普通、困难】、新的开始、读档、播放/暂停bgm、退出游戏），可以存档读档，有悔棋功能，有落子提示，有可以手动切换而且可以随时暂停和播放的bgm。主菜单的背景画面在每一次进入/回到主菜单时会随机更换不同的主界面皮肤

在下棋的界面，玩家可以选择悔棋、存档、回到主菜单或者暂时进入“点唱机”界面来切换/暂停/播放bgm。

对于胜利和失败两种结局，有不同的结算画面，在结算画面中可以选择退出游戏、回到主菜单或者悔一步棋。

二、功能实现

1、棋盘和棋子贴图

棋盘的画面并非是垂直俯视的，而是类似于斜上方的视角。这就导致在摆放棋子贴图的时候很难去找到一个公式将棋盘上交叉点的坐标 转化为 画面中点的坐标。为了解决这个问题，我们测量出棋盘上每一个交叉点的横纵坐标，用数组记录下来。在贴图的时候以数组中的数据作为xy坐标值。

还可以发现，棋子的形状也是不规则的，为了不让多余的部分挡住棋盘，采用原图和黑底白面的图片以特殊形式叠加的方式来消除图片背景。

2、存档和读档

存档就是将棋盘上每一点的状态储存在一个文档里，同时在画面上提示“存档成功”。

读档是在主菜单里可选的功能，玩家点击读档后，首先进入空白的棋盘画面，然后将已经存档的文件中的信息读入当前棋盘，再检索每一点是否有棋子，如果有就把对应的贴图贴上去。

3、主菜单

通过判断鼠标点击位置区间的不同来判断所选择的按钮，并执行对应的函数。由于读档功能已经介绍过了，在下方的截图中，并没有把读档的那部分截进去。

关于主菜单随机背景，是把各个背景储存在一个IMAGE数组中，然后通过随机数去生成随机背景。


4、悔棋

大体思路是，在每一次玩家下棋的时候，在改变棋盘数据和呈现贴图之前，先对棋盘和画面进行一个复制。如果玩家下一步点了悔棋，那么就把复制的内容呈现出来，达到悔棋的效果。
由于一次游戏可以多次回到主界面，为了避免 下一会儿棋->回到主界面->新开始->立马点悔棋 可能引发的调出上一次游戏画面的bug，在每一次回到主界面时执行一次reset


5、落子提示

每一次电脑下棋时，贴红白相间的贴图，第二次电脑下棋前，将贴图贴回白色，达到落子提示的效果。

我们发现这样跟悔棋的“复制画面”有些冲突，可能导致复制到的画面是有红色棋子的。再贴上来就有了多个红色棋子。为了避免此bug，对悔棋的红棋问题做特殊处理，简单来说就是直接放个白贴图把不应该出现的红棋盖住。

6、背景音乐

通过鼠标的点击位置判断用户选择了哪首bgm，是否选择了暂停/播放。Bgm数量不止一首，截图时候不一一列举。

点唱机画面进入时先复制棋盘画面，退出时再将复制的棋盘画面贴上来。

0、vs结构

在一个cpp下面写这么多东西，难找难改，而且十分长。所以采用了多文件的结构。

三、行棋算法

0、提子判断

把自杀也算做提子的话，提子判断其实也就是胜负判断。

首先我们有一个名为tizi_no的布尔函数，调用参数（行数i，列数j，棋子颜色c）。返回1代表i，j处c颜色的棋子没有产生提子，0则代表有提子。还有一个名为tizi的void函数，来判断i，j位的c棋子有没有被提掉。
我们发现，这两个函数要求调用时i，j位已经有棋子，而且只能判断主棋盘的提子情况。那其实多调用一个棋盘作为参数，在一开始加入qipan[i][j]=yuan的语句的话，就可以计算任意棋盘的提子情况，而且不需要先令i，j处有子。这个想法我们将它制作成了名为supertizi_no的新函数。因为跟上面的差不多少所以不再详细讲解。

1、easy模式

这个就是随机，先找出所有可行点然后随机选点。

2、normal模式

Normal模式采用负极大值算法，并随着对局进行增加搜索深度。对一个局面的估值为对方禁入点的数量减去我方禁入点的数量。

3、hard模式

采用价值评估算法，价值评估和打散规则思路来自
郭倩宇 (2019). "基于价值评估的不围棋递归算法". 华东师范大学学报(自然科学版) (1000-5641), (1), p. 58.

这种方法涉及“点的价值”，i，j点的价值为：先将此点模拟为黑棋，计算白棋禁入点的数目；再将此点模拟为白棋，计算黑棋禁入点的数目。最后将它们加起来作为该点的价值。
每次行棋，选取价值最大的点进行落子。如有价值相同的，再比较第二层价值（第二层价值就是指，已经将该点模拟成黑棋，场上其他点的最大价值）。第二层相同再比较第三层，以此类推。如此思路需要广度优先搜索，可以用链表来实现。

另外，在终盘时，可行点比较少，可以调用normal的函数进行深度无限的负极大值搜索，找到必胜的路径。
Value1的上述区别体现在这里：

另外，在开局阶段，容易得到一层价值为0。在这种情况下，采用打散规则。在下方介绍。

将两点横纵坐标的差的绝对值之和记为两点的曼哈顿距离，选取与棋盘上的已有子的曼哈顿距离最大的点作为行棋点。

实现方面，我们让棋盘上所有已有的子进行以曼哈顿距离为单位的“生长”，最后在棋盘上空下来的点就是所要找的点，当然也有可能有多个这样的点，这时从这些点里随机挑选一个。

End

参考：
郭倩宇 (2019). "基于价值评估的不围棋递归算法". 华东师范大学学报(自然科学版) (1000-5641), (1), p. 58.


